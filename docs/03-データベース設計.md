# データベース設計

## 3.1 DynamoDBテーブル一覧

本システムでは、以下の5つのDynamoDBテーブルを使用します。

| テーブル名 | 主な用途 | パーティションキー | ソートキー |
|-----------|---------|------------------|-----------|
| UserStamps | ユーザーのスタンプ収集状況 | UserId | StampId |
| StampMasters | スタンプマスタ情報 | StampId | - |
| Users | ユーザー基本情報 | UserId | - |
| Rankings | ランキング情報 | Period | Rank |
| Friends | 友達関係 | UserId | FriendId |

## 3.2 DynamoDBテーブル構成

### テーブル1: UserStamps (ユーザーのスタンプ収集状況)
| 項目名 | 型 | 説明 |
|--------|-----|------|
| UserId | String (パーティションキー) | LINE UID |
| StampId | String (ソートキー) | スタンプID |
| CollectedAt | Number | 収集日時（Unixタイムスタンプ） |
| Method | String | 収集方法（GPS/IMAGE） |
| TTL | Number | データ有効期限（削除用） |

### テーブル2: StampMasters (スタンプマスタ情報)
| 項目名 | 型 | 説明 |
|--------|-----|------|
| StampId | String (パーティションキー) | スタンプID |
| Name | String | スタンプ名 |
| Description | String | 説明 |
| Type | String | 収集タイプ（GPS/IMAGE） |
| Location | Map | GPS座標（lat, lng, radius） |
| ImageLabel | String | 画像認識用ラベル |
| ValidFrom | Number | 有効開始日時 |
| ValidTo | Number | 有効終了日時 |

### テーブル3: Users (ユーザー基本情報)
| 項目名 | 型 | 説明 |
|--------|-----|------|
| UserId | String (パーティションキー) | LINE UID |
| DisplayName | String | 表示名 |
| LineId | String | LINE ID |
| CreatedAt | Number | 登録日時 |
| LastLoginAt | Number | 最終ログイン日時 |

### テーブル4: Rankings (ランキング情報)
| 項目名 | 型 | 説明 |
|--------|-----|------|
| Period | String (パーティションキー) | 期間キー（例: "weekly-2025-W45", "monthly-2025-11"） |
| Rank | Number (ソートキー) | 順位（1, 2, 3, ...） |
| UserId | String | ユーザーID |
| StampCount | Number | スタンプ数 |
| DisplayName | String | 表示名 |
| UpdatedAt | Number | 更新日時（Unixタイムスタンプ） |

**注意事項**:
- 週間ランキング: `Period` = "weekly-{年}-W{週番号}"（例: "weekly-2025-W45"）
- 月間ランキング: `Period` = "monthly-{年}-{月}"（例: "monthly-2025-11"）
- ランキングは定期的に再計算され、既存データは削除後に新規データで置き換えられます

### テーブル5: Friends (友達関係)
| 項目名 | 型 | 説明 |
|--------|-----|------|
| UserId | String (パーティションキー) | ユーザーID |
| FriendId | String (ソートキー) | 友達のユーザーID |
| CreatedAt | Number | 友達関係作成日時（Unixタイムスタンプ） |
| Status | String | ステータス（"active", "blocked"） |

**注意事項**:
- 友達関係は双方向で保存されます（A→B と B→A の両方のレコードが存在）
- `Status`が"active"の友達のみがランキングに含まれます
- 自分自身を友達として追加することはできません

## 3.3 テーブル間の関係

```
Users (1) ──< (N) UserStamps
  │
  ├──< (N) Friends (UserId)
  │
  └──< (N) Friends (FriendId)

StampMasters (1) ──< (N) UserStamps

Rankings
  └── UserId は Users.UserId を参照
```

## 3.4 データ例

### UserStamps テーブルのデータ例
```json
{
  "UserId": "U1234567890abcdefghijklmnopqrstuv",
  "StampId": "STAMP_001",
  "CollectedAt": 1704067200,
  "Method": "GPS",
  "TTL": 1735689600
}
```

### StampMasters テーブルのデータ例
```json
{
  "StampId": "STAMP_001",
  "Name": "東京タワー",
  "Description": "東京タワーでスタンプを獲得",
  "Type": "GPS",
  "Location": {
    "lat": 35.6586,
    "lng": 139.7454,
    "radius": 100
  },
  "ValidFrom": 1704067200,
  "ValidTo": 1735689600
}
```

### Users テーブルのデータ例
```json
{
  "UserId": "U1234567890abcdefghijklmnopqrstuv",
  "DisplayName": "山田太郎",
  "LineId": "yamada_taro",
  "CreatedAt": 1704067200,
  "LastLoginAt": 1704153600
}
```

### Rankings テーブルのデータ例
```json
{
  "Period": "weekly-2025-W45",
  "Rank": 1,
  "UserId": "U1234567890abcdefghijklmnopqrstuv",
  "StampCount": 15,
  "DisplayName": "山田太郎",
  "UpdatedAt": 1704153600
}
```

### Friends テーブルのデータ例
```json
{
  "UserId": "U1234567890abcdefghijklmnopqrstuv",
  "FriendId": "U0987654321zyxwvutsrqponmlkjihgf",
  "CreatedAt": 1704067200,
  "Status": "active"
}
```

## 3.5 クエリパターン

### よく使用されるクエリ

1. **ユーザーのスタンプ一覧取得**
   - テーブル: `UserStamps`
   - キー: `UserId` (パーティションキー)
   - 操作: Query

2. **特定のスタンプマスター情報取得**
   - テーブル: `StampMasters`
   - キー: `StampId` (パーティションキー)
   - 操作: GetItem

3. **ユーザー情報取得**
   - テーブル: `Users`
   - キー: `UserId` (パーティションキー)
   - 操作: GetItem

4. **期間別ランキング取得**
   - テーブル: `Rankings`
   - キー: `Period` (パーティションキー)
   - 操作: Query (Rankでソート)

5. **友達リスト取得**
   - テーブル: `Friends`
   - キー: `UserId` (パーティションキー)
   - 操作: Query (Status='active'でフィルタ)

## 3.6 位置情報検証ロジック

```python
import math

def calculate_distance(lat1, lon1, lat2, lon2):
    """
    Haversine公式を使用して2点間の距離を計算（単位：メートル）
    """
    R = 6371000  # 地球の半径（メートル）
    
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)
    
    a = math.sin(delta_phi/2)**2 + \
        math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda/2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    
    return R * c
```

## 3.7 パフォーマンス考慮事項

### スキャン操作の回避
- `UserStamps`テーブルの全件スキャンは、データ量が増えるとコストと時間がかかります
- ランキング計算時は、必要に応じてGSI（Global Secondary Index）の追加を検討してください

### TTLの活用
- `UserStamps`テーブルの`TTL`属性を活用して、古いデータを自動削除できます
- データ保持期間に応じて適切なTTL値を設定してください

### バッチ処理
- ランキング計算は定期的なバッチ処理（EventBridge + Lambda）で実行することを推奨します
- リアルタイムでのランキング計算は避け、事前計算した結果を参照する方式を採用しています

